diff --git a/src/freedreno/drm/kgsl/kgsl_bo.c b/src/freedreno/drm/kgsl/kgsl_bo.c
index d42400207ad..f0c8b5a7c1a 100644
--- a/src/freedreno/drm/kgsl/kgsl_bo.c
+++ b/src/freedreno/drm/kgsl/kgsl_bo.c
@@ -4,6 +4,7 @@
 #include "util/os_mman.h"
 
 #include <linux/dma-heap.h>
+#include <errno.h>
 
 static uint64_t
 kgsl_bo_iova(struct fd_bo *bo)
@@ -233,49 +234,136 @@ kgsl_bo_from_dmabuf(struct fd_device *dev, int fd)
 }
 
 static int
 dma_heap_alloc(uint64_t size)
 {
    int ret;
    int dma_heap = open("/dev/dma_heap/system", O_RDONLY);
 
    if (dma_heap < 0) {
-      int ion_heap = open("/dev/ion", O_RDONLY);
+      /* Cache detected ION ABI:
+       *   -1 = unknown, 0 = legacy(handle->share fd), 1 = new(fd returned directly)
+       */
+      static int ion_abi = -1;
+      const __u32 heap_mask = (1U << 0) | (1U << 25); /* system heap masks used by droidvm patch */
+
+      int ion_heap = open("/dev/ion", O_RDWR | O_CLOEXEC);
 
       if (ion_heap < 0)
          return -1;
 
-      struct ion_allocation_data {
-         __u64 len;
-         __u32 heap_id_mask;
-         __u32 flags;
-         __u32 fd;
-         __u32 unused;
-      } alloc_data = {
-         .len = size,
-         /* ION_HEAP_SYSTEM | ION_SYSTEM_HEAP_ID */
-         .heap_id_mask = (1U << 0) | (1U << 25),
-         .flags = 0, /* uncached */
-      };
-
-      ret = kgsl_pipe_safe_ioctl(ion_heap, _IOWR('I', 0, struct ion_allocation_data),
-                      &alloc_data);
-
-      close(ion_heap);
-
-      if (ret)
-         return -1;
-
-      return alloc_data.fd;
+      /* --- Try "new" ION ABI first (fd returned directly) ---
+       * Some kernels will return ENOTTY/EINVAL if this ABI isn't supported.
+       */
+      if (ion_abi != 0) {
+         struct ion_allocation_data_new_uapi {
+            __u64 len;
+            __u32 heap_id_mask;
+            __u32 flags;
+            __u32 fd;
+            __u32 unused;
+         } alloc_data = {
+            .len = size,
+            .heap_id_mask = heap_mask,
+            .flags = 0, /* uncached */
+            .fd = 0,
+            .unused = 0,
+         };
+
+         ret = kgsl_pipe_safe_ioctl(ion_heap,
+                                    _IOWR('I', 0, struct ion_allocation_data_new_uapi),
+                                    &alloc_data);
+
+         if (!ret && (int)alloc_data.fd >= 0) {
+            ion_abi = 1;
+            close(ion_heap);
+            return (int)alloc_data.fd;
+         }
+
+         if (ret && (errno == ENOTTY || errno == EINVAL)) {
+            /* Wrong ABI: permanently switch to legacy path */
+            ion_abi = 0;
+         } else {
+            /* Real allocation error: don't hide it by trying other ABI */
+            int e = errno;
+            close(ion_heap);
+            errno = e;
+            return -1;
+         }
+      }
+
+      /* --- Legacy ION ABI fallback (handle -> share fd -> free handle) --- */
+      struct ion_allocation_data_legacy_uapi {
+         __u64 len;
+         __u64 align;
+         __u32 heap_id_mask;
+         __u32 flags;
+         __u32 handle;
+      } alloc_legacy = {
+         .len = size,
+         .align = 0,
+         .heap_id_mask = heap_mask,
+         .flags = 0, /* uncached */
+         .handle = 0,
+      };
+
+      ret = kgsl_pipe_safe_ioctl(ion_heap,
+                                 _IOWR('I', 0, struct ion_allocation_data_legacy_uapi),
+                                 &alloc_legacy);
+      if (ret) {
+         int e = errno;
+         close(ion_heap);
+         errno = e;
+         return -1;
+      }
+
+      struct ion_fd_data_legacy_uapi {
+         __u32 handle;
+         __u32 fd;
+      } share = {
+         .handle = alloc_legacy.handle,
+         .fd = 0,
+      };
+
+      ret = kgsl_pipe_safe_ioctl(ion_heap,
+                                 _IOWR('I', 4, struct ion_fd_data_legacy_uapi),
+                                 &share);
+      int share_errno = errno;
+
+      /* Best-effort free the handle (avoid leaking handle refs) */
+      struct ion_handle_data_legacy_uapi {
+         __u32 handle;
+      } free_h = {
+         .handle = alloc_legacy.handle,
+      };
+      kgsl_pipe_safe_ioctl(ion_heap,
+                           _IOWR('I', 1, struct ion_handle_data_legacy_uapi),
+                           &free_h);
+
+      close(ion_heap);
+
+      if (ret) {
+         errno = share_errno;
+         return -1;
+      }
+
+      return (int)share.fd;
    } else {
       struct dma_heap_allocation_data alloc_data = {
          .len = size,
          .fd_flags = O_RDWR | O_CLOEXEC,
       };
 
       ret = kgsl_pipe_safe_ioctl(dma_heap, DMA_HEAP_IOCTL_ALLOC, &alloc_data);
 
       close(dma_heap);
 
       if (ret)
          return -1;
 
       return alloc_data.fd;
    }
 }
