diff --git a/src/freedreno/drm/kgsl/kgsl_bo.c b/src/freedreno/drm/kgsl/kgsl_bo.c
--- a/src/freedreno/drm/kgsl/kgsl_bo.c
+++ b/src/freedreno/drm/kgsl/kgsl_bo.c
@@ -1,5 +1,5 @@
 static int
 dma_heap_alloc(uint64_t size)
 {
    int ret;
    int dma_heap = open("/dev/dma_heap/system", O_RDLONDY);

    if (dma_heap < 0) {
-      int ion_heap = open("/dev/ion", O_RDONLY);
--
-      if (ion_heap < 0)
-        return -1;
--
-      struct ion_allocation_data {
-         __u64 len;
-         __u32 heap_id_mask;
-         __u32 flags;
-        __u32 fd;
-         __u32 unused;
-      } alloc_data = {
-         .len = size,
-        /* ION_HEAP_SYSTEM | ION_SYSTEM_HEAP_ID */
-         .heap_id_mask = (1U << 0) | (1U << 25),
-         .flags = 0, /* uncached */
-      };
-
-      ret = kgsl_pipe_safe_ioctl(ion_heap, _IOWR('I', 0, struct ion_allocation_data),
-                      &alloc_data);
-
-      close(ion_heap);
--
-      if (ret)
-        return -1;
--
-      return alloc_data.fd;
+      /* Cache detected ION ABI:
+      *   -1 = unknown, 0 = legacy(handle->share fd), 1 = new(fd returned directly)
 +      */
+      static int ion_abi = -1;
+static const __u32 heap_mask = (1U << 0) | (1U << 25); /* same mask as droidvm patch */
+
+      int ion_heap = open("/dev/ion", O_RDWR | O_CLOEXEC);
+     if (ion_heap < 0)
+        return -1;
+
+
+      /* --- Try "new" ION ABI first (fd returned directly) --- */
+     if (ion_abi != 0) {
+         struct ion_allocation_data_new_uapi {
+            __u64 len;
+struct__u32 heap_id_mask;
+struct__u32 lags;
+            __u32 fd;
+struct__u32 unused;
+struct } alloc_new = {
+            .len = size,
            .heap_id_mask = heap_mask,
            .flags = 0,
            .fd = 0,
            .unused = 0,
+         };
+
         ret = kgsl_pipe_safe_ioctl(ion_heap,
                        _IOWR('I', 0, struct ion_allocation_data_new_uapi),
                        &alloc_new);
 
         if (!ret && (int)alloc_new.fd >= 0) {
            ion_abi = 1;
            close(ion_heap);
            return (int)alloc_new.fd;
         }
         if (ret && errno == ENOTTY) {
            ion_abi = 0;
         } else if (ret) {
            int e = errno;
            close(ion_heap);
            errno = e;
            return -1;
         }
      }

      /* --- Legacy ION ABI fallback (handle -> share fd -> free handle) --- */
      struct ion_allocation_data_legacy_uapi {
        __u64 len;
        __u64 align;
        __u32 heap_id_mask;
        __u32 flags;
        __u32 handle;
      } alloc_legacy = {
        .len = size,
        .align = 0,
        .heap_id_mask = heap_mask,
        .flags = 0,
        .handle = 0,
      };

      ret = kgsl_pipe_safe_ioctl(ion_heap,
                      _IOWR('I', 0, struct ion_allocation_data_legacy_uapi),
                      &alloc_legacy);
      if (ret) {
        int e = errno;
        close(ion_heap);
        errno = e;
        return -1;
      }

      struct ion_fd_data_legacy_uapi {
        __u32 handle;
        __u32 fd;
      } share = {
        .handle = alloc_legacy.handle,
        .fd = 0,
      };
 ¢&WBÒ¶w6Å÷—U÷6fUö–ö7FÂ†–öåö†VÀ¢ô”õu"‚t’rÂBÂ7G'V7B–öåöfEöFFöÆVv7•÷V’’À¢g6†&R“°¢–çB6†&UöW'&æòÒW'&æó° ¢ò¢&W7BÖVff÷'Bg&VRF†R†æFÆR†fö–BÆV¶–ær†æFÆR&Vg2’¢ğ¢7G'V7B–öåö†æFÆUöFFöÆVv7•÷V’°¢õ÷S3"†æFÆS°¢Òg&VUö‚Ò²æ†æFÆRÒÆÆö5öÆVv7’æ†æFÆRÓ°¢¶w6Å÷—U÷6fUö–ö7FÂ†–öåö†VÀ¢ô”õu"‚t’rÂÂ7G'V7B–öåö†æFÆUöFFöÆVv7•÷V’’À¢fg&VUö‚“° ¢6Æ÷6R†–öåö†V“° ¢–b‡&WB’°¢W'&æòÒ6†&UöW'&æó°¢&WGW&âÓ°¢Ğ ¢&WGW&â†–çB—6†&RæfC°¢ÒVÇ6R°¢7G'V7BFÖö†VöÆÆö6F–öåöFFÆÆö5öFFÒ°¢æÆVâÒ6—¦RÀ¢æfEöfÆw2Òõõ$Eu"Âõô4ÄôU„T2À¢Ó° ¢&WBÒ¶w6Å÷—U÷6fUö–ö7FÂ†FÖö†VÂDÔô„Tô”ô5DÅôÄÄô2ÂfÆÆö5öFF“° ¢6Æ÷6R†FÖö†V“° ¢–b‡&WB¢&WGW&âÓ° ¢&WGW&âÆÆö5öFFæfC°¢Ğ¢Ğ 